# Функциональное программирование. Лабораторная работа №1.

Вариант: 2, 29.


Цель: освоить базовые приёмы и абстракции функционального программирования: функции, поток управления и поток данных, сопоставление с образцом, рекурсия, свёртка, отображение, работа с функциями как с данными, списки.

## Условия задач

### Задача 2

By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.


### Задача 29

How many distinct terms are in the sequence generated by a^b for 2 <= a <= 100 and 2 <= b <= 100?


## Реализация

Решение представленных задач в императивном стиле на языке Golang

```csharp
public static class FibUtils
{
    public static int SumOfEvenFibonacciTermsRec(int border)
    {
        var sum = 0;
        for (var i = 1; Fib(i) < border; i++)
        {
            var fib = Fib(i);

            if (fib % 2 == 0) sum += fib;
        }

        return sum;
    }

    public static int SumOfEvenFibonacciTermsTail(int border)
    {
        var sum = 0;
        for (var i = 1; FibTail(i) < border; i++)
        {
            var fib = FibTail(i);

            if (fib % 2 == 0) sum += fib;
        }

        return sum;
    }

    private static int Fib(int n) => n < 2 ? n : Fib(n - 1) + Fib(n - 2);

    private static int FibTail(int n) => FibTailRecursion(n, 1, 1);
    
    private static int FibTailRecursion(int n, int x, int y) =>
        n switch
        {
            1 => x,
            2 => y,
            _ => FibTailRecursion(n - 1, y, x + y)
        };
}

public static class Program
{
    public static void Main(string[] args)
    {
        Console.WriteLine("Euler 2 problem");
        const int border = 4000000;
        Console.WriteLine("Sum of the even-valued terms of Fibonacci sequence using recursion: " +
                          $"{FibUtils.SumOfEvenFibonacciTermsRec(border)}");
        Console.WriteLine("Sum of the even-valued terms of Fibonacci sequence using tail recursion: " +
                          $"{FibUtils.SumOfEvenFibonacciTermsTail(border)}");
    }
}
```

```csharp
public static class Program
{
    public static void Main(string[] args)
    {
        Console.WriteLine("Euler 29 problem");
        const int min = 2;
        const int max = 100;
        var lst = new List<double>();
        for (var a = min; a <= max; a++)
        {
            for (var b = min; b <= max; b++)
            {
                lst.Add(Math.Pow(a, b));
            }
        }
        var distinctResult = lst.Distinct().ToList();
        distinctResult.Sort();
        Console.WriteLine($"Amount of distinct terms are in the sequence generated by a^b for 2 <= a <= 100 and 2 <= b <= 100?: {distinctResult.Count}");
        Console.ReadLine();
    }
}
```

### F#: задача 2

- Рекурсия:
```fsharp
let rec fibonacciSumNonTailRec a b border predicate =
    if a > border then
        0
    else
        let currentTerm = if predicate a then a else 0
        currentTerm + fibonacciSumNonTailRec b (a + b) border predicate
```

- Хвостовая рекурсия:
```fsharp
let rec fibonacciSumTailRec a b border predicate acc =
    if a > border then
        acc
    else
        fibonacciSumTailRec b (a + b) border predicate (if predicate a then acc + a else acc)
```

- Модульная реализация:
```fsharp
let generateFibonacciSequenceList border =
    let mutable list = []
    let mutable i = 1

    while fibonacciRec i < border do
        list <- list @ [ fibonacciRec i ]
        i <- inc i

    list

let sumList = List.fold (+) 0

let filterAndSumFibonacciSequence border predicate =
    generateFibonacciSequenceList border |> List.filter predicate |> sumList
```

- С использованием map:
```fsharp
let rec fibonacciRec n =
    match n with
    | 1
    | 2 -> 1
    | n -> fibonacciRec (n - 1) + fibonacciRec (n - 2)

let fibonacciWithMap n = [ 1..n ] |> List.map fibonacciRec

let sumOfFibonacciWithWithMap border predicate =
    let mutable n = 1

    while fibonacciRec n < border do
        n <- inc n

    fibonacciWithMap n |> filterList predicate |> sumList
```

- Бесконечные списки:
```fsharp
let fibonacciFold n =
    [ 1..n ] |> List.fold (fun (a, b) _ -> b, a + b) (0, 1) |> fst

let sumEndlessSequence border predicate =
    Seq.initInfinite fibonacciFold
    |> Seq.skip 1
    |> Seq.takeWhile (lessThan border)
    |> Seq.filter predicate
    |> Seq.toList
    |> sumList
```


### F#: задача 29

- Рекурсия:
```fsharp
let rec distinctPowersNonTailRecSet a border set =
    if a > border then
        set
    else
        Set.union set (distinctPowersNonTailRecSet (a + 1.0) border (calculatePowersSet a 2 border set))

let distinctPowersNonTailRecCount a border =
    distinctPowersTailRecSet a border Set.empty |> Set.count
```

- Хвостовая рекурсия:
```fsharp
let rec distinctPowersTailRecSet a border set =
    if a > border then
        set
    else
        distinctPowersTailRecSet (a + 1.0) border (calculatePowersSet a 2 border set)

let distinctPowersTailRecCount a border =
    distinctPowersTailRecSet a border Set.empty |> Set.count
```

- Модульная реализация:
```fsharp
let rec generatePowersList a border list =
    if a > border then
        list
    else
        List.append list (generatePowersList (a + 1.0) border (Set.toList (calculatePowersSet a 2 border Set.empty)))

let distinctPowersModularCount a border =
    generatePowersList a border List.Empty |> List.distinct |> List.length
```

- С использованием map:
```fsharp
let generatePowersListWithMap a border =
    let baseRange = [ a..border ]
    let exponentRange = [ 2..border ]

    let powersList =
        List.map (fun a -> List.map (fun b -> float (a) ** float (b)) exponentRange) baseRange

    powersList |> List.concat

let distinctPowersWithMapCount a border =
    generatePowersListWithMap a border |> List.distinct |> List.length
```

- Бесконечные списки:
```fsharp
???
```
